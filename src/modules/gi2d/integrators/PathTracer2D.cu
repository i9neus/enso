#include "PathTracer2D.cuh"
#include "kernels/math/CudaColourUtils.cuh"
#include "generic/Hash.h"

#include "../lights/Light.cuh"
#include "../RenderCtx.cuh"

using namespace Cuda;

namespace GI2D
{
    __device__ int Device::PathTracer2D::Trace(const Ray2D& ray, HitCtx2D& hit, RenderCtx& renderCtx) const
    {
        hit.tracableIdx = kInvalidHit;
        hit.flags = 0;

        const auto& bih = *m_scene.tracableBIH;
        const auto& tracables = *m_scene.tracables;
        auto onIntersect = [&tracables, &ray, &hit](const uint* primRange, RayRange2D& range) -> float
        {
            for (uint idx = primRange[0]; idx < primRange[1]; ++idx)
            {
                if (tracables[idx]->IntersectRay(ray, hit))
                {
                    if (hit.tFar < range.tFar)
                    {
                        range.tFar = hit.tFar;
                        hit.tracableIdx = idx;                        
                    }
                }
            }
        };
        bih.TestRay(ray, kFltMax, onIntersect);        

        if (hit.tracableIdx != kInvalidHit)
        {
            hit.p = ray.PointAt(hit.tFar);
            hit.n = normalize(hit.n);
            hit.depth++;
            
            //if (renderCtx.IsDebug()) printf("Hit: %i: %f, [%f, %f] (%f, %f)\n", hit.tracableIdx, hit.tFar, hit.p.x, hit.p.y, hit.n.x, hit.n.y);
        }
        return hit.tracableIdx;
    }

    __device__ bool Device::PathTracer2D::Shade(Ray2D& ray, const HitCtx2D& hit, RenderCtx& renderCtx) const
    {
        const vec3 xi = renderCtx.rng.Rand<0, 1, 2>();

        // Sample the direct component
        if (xi.z < 0.5)
        {     
            const auto& lights = *m_scene.lights;
            if (lights.IsEmpty()) { return false; }

            // Choose a light at random
            const int lightIdx = max(lights.Size() - 1, int(xi.x * lights.Size()));

            // Sample the light
            vec2 extantLight;
            vec3 LLight;
            float pdfLight;
            if (!lights[lightIdx]->Sample(ray, hit, xi.y, extantLight, LLight, pdfLight)) { return false; }

            // Derive the extant ray from the incident ray
            ray.DeriveDirectSample(hit, extantLight, LLight, lightIdx);
        }
        // Indirect light sampling	
        else
        {
            // Sample a 2D Lambertian BRDF
            vec2 d = vec2(xi.y, sqrt(1.0 - sqr(xi.y)));
            d = normalize(hit.n * d.y + vec2(hit.n.y, -hit.n.x) * d.x);

            //if (renderCtx.IsDebug()) printf("Scatter: [%f, %f] %f\n", hit.p.x, hit.p.y, hit.kickoff);

            ray.DeriveIndirectSample(hit, d, kOne);
        }

        return true;
    }
    
    __device__ void Device::PathTracer2D::Integrate(RenderCtx& renderCtx) const
    {    
        assert(m_scene.tracableBIH && m_scene.tracables);
        
        Ray2D ray;
        HitCtx2D hit;
        if (!renderCtx.camera.CreateRay(ray, hit, renderCtx)) { return; }        
      
        constexpr int kMaxDepth = 2;
        for (int depth = 0; depth < kMaxDepth; ++depth)
        {            
            //if (renderCtx.IsDebug()) printf("%i: %f, %f -> %f, %f\n", depth, ray.o.x, ray.o.y, ray.d.x, ray.d.y);
            
            // Trace the rays generated by the shading pass
            if (Trace(ray, hit, renderCtx) == kInvalidHit) 
            { 
                //if (renderCtx.IsDebug()) printf("Miss\n");
                break; 
            }

            auto& tracable = *(*m_scene.tracables)[hit.tracableIdx];
            auto hitLightIdx = tracable.GetLightIdx();
            if (ray.IsDirectSample())
            {
                if (ray.lightIdx == hitLightIdx)
                {
                    renderCtx.camera.Accumulate(vec4(ray.throughput, 0.0f), renderCtx);
                }
                continue;
            }  

            if (depth == kMaxDepth - 1 || hitLightIdx != kTracableNotALight) { break; }            
            
            if(!Shade(ray, hit, renderCtx)) { break; }

            hit.PrepareNext();
        }
    }
    DEFINE_KERNEL_PASSTHROUGH(Integrate);   
}
