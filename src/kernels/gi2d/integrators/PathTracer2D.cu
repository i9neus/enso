#include "PathTracer2D.cuh"
#include "kernels/math/CudaColourUtils.cuh"
#include "generic/Hash.h"

#include "../lights/Light.cuh"
#include "../RenderCtx.cuh"

using namespace Cuda;

namespace GI2D
{
    __device__ int Device::PathTracer2D::Trace(const Ray2D& ray, HitCtx2D& hit, RenderCtx& renderCtx) const
    {
        hit.tracableIdx = kInvalidHit;

        const auto& bih = *m_scene.tracableBIH;
        const auto& tracables = *m_scene.tracables;
        auto onIntersect = [&tracables, &ray, &hit](const uint* primRange, RayRange2D& range) -> float
        {
            for (uint idx = primRange[0]; idx < primRange[1]; ++idx)
            {
                if (tracables[idx]->IntersectRay(ray, hit))
                {
                    if (hit.tFar < range.tFar)
                    {
                        range.tFar = hit.tFar;
                        hit.tracableIdx = idx;
                    }
                }
            }
        };
        bih.TestRay(ray, kFltMax, onIntersect);

        return hit.tracableIdx;
    }

    __device__ bool Device::PathTracer2D::Shade(Ray2D& ray, const HitCtx2D& hit, RenderCtx& renderCtx) const
    {
        const auto& lights = *m_scene.lights;
        if (lights.IsEmpty()) { return false; }

        const vec2 xi = renderCtx.rng.Rand<0, 1>();
        
        // Choose a light at random
        const int lightIdx = max(lights.Size() - 1, int(xi.x * lights.Size()));

        // Sample the light
        vec2 extantLight;
        vec3 LLight;
        float pdfLight;
        if (!lights[lightIdx]->Sample(ray, hit, xi.y, extantLight, LLight, pdfLight)) { return false; }

        // Derive the extant ray from the incident ray
        ray.DeriveLightSample(hit, extantLight, LLight, lightIdx);

        return true;
    }
    
    __device__ void Device::PathTracer2D::Integrate(RenderCtx& renderCtx) const
    {    
        assert(m_scene.tracableBIH && m_scene.tracables);
        
        Ray2D ray;
        HitCtx2D hit;
        if (!renderCtx.camera.CreateRay(ray, hit, renderCtx)) { return; }
      
        constexpr int kMaxDepth = 1;
        for (int depth = 0; depth < kMaxDepth; ++depth)
        {
            if (!Shade(ray, hit, renderCtx)) { break; }
            
            // Trace the rays generated by the shading pass
            if (Trace(ray, hit, renderCtx) == kInvalidHit) { break; }

            if (ray.IsLightSample())
            {
                if (ray.lightIdx == (*m_scene.tracables)[hit.tracableIdx]->GetLightIdx())
                {
                    renderCtx.camera.Accumulate(vec4(ray.throughput, 0.0f), renderCtx);
                }
                continue;
            }            
        }
        //renderCtx.camera.Accumulate(vec4(kZero, 1.0f), renderCtx);
    }
    DEFINE_KERNEL_PASSTHROUGH(Integrate);   
}